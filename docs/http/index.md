[看完这篇HTTP，跟面试官扯皮就没问题了](https://juejin.cn/post/6844904045572800525?share_token=3bf2b4d3-47cd-4781-b3af-7b884010a5e7#heading-4)

## HTTP 和 HTTPS 的区别

- HTTP 是 `明文传输，不安全的`；HTTPS是`SSL的加密传输，比较安全`
- HTTP标准端口是 `80`；HTTPS 是 `443`
- HTTP是 `无状态` 的；HTTPS 的 `有状态` 的
- HTTP `不用认证证书，免费`；HTTPS `需要认证证书`
- `连接方式不同`，`HTTP 三次握手`，HTTPS 中 TLS 版本7次，TLS1.3版本6次
- HTTP 在 `OSI 网络模型`中是 `应用层`；HTTPS的 `TLS 在 传输层`

HTTP 一般是明文传输，很容易被窃取重要信息；HTTPS 是以安全为目标的HTTP通道，在HTTP的基础上通过 **传输加密** 和 **身份认证** 保证了传输过程的安全性，在HTTP的基础上增加了 **SSL层**

## HTTP2.0 和 HTTP 1.x 相比的新特性

- 新的二进制格式
- 多路复用
- Header 压缩
- 服务端推送

## 从 URL 输入到回车发生了什么

[从输入URL开始建立前端知识体系](https://juejin.cn/post/6935232082482298911)

- DNS 解析：将域名映射成IP地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析报文渲染页面
- 断开连接：TCP 四次挥手

在地址栏输入URL地址，浏览器会想DNS域名服务器提供网址，然后完成URL到IP地址的映射。然后将请求发送给服务器。在由服务器返回我们要的结果（以html编码格式返回给浏览器），浏览器执行html编码，将结果显示在浏览器的正文。这是一个浏览器发起请求和接受响应的过程。

## TCP 三次握手和四次挥手

三次握手
1. 第一次：客户端发起，向服务器端发送报文信息
2. 第二次：服务端发起，收到信息后进行处理，然后发送报文信息给客户端
3. 第三次：客户端发起，收到信息后，发送一个确认收到的回复信息，表示收到

四次握手
1. 第一次：客户端发起，告诉服务端要断开
2. 第二次：服务端发起，表示已经收到，但是需要进行收尾工作
3. 第三次：服务端发起，收尾工作完成，告诉客户端
4. 第三次：客户端发起，表示收到，通知服务器可以断开连接了，服务端收到后断开

## 浏览器缓存策略

[从输入URL开始建立前端知识体系](https://juejin.cn/post/6935232082482298911)

1. 第一次请求，没有缓存，直接向服务器发请求，并将结果存入缓存中
2. 第二次请求，在强缓存时间内，缓存未过期，浏览器直接使用缓存作为结果并返回200
3. 第三次请求，清缓存过期，进入协商缓存，向服务器请求，通过Header中携带 `If-Modified-Since`（对应浏览器返回的 `last-Modify`）或 `If-None-Match` （对应浏览器返回的 `Etag`）校验缓存内容是否有更新，`Etag` 的优先级更高
4. 缓存资源没有更新，返回 `304`，浏览器继续使用缓存，并更新强制缓存时间；
   缓存资源有更新，缓存失效，返回 `200`，重新返回资源和缓存标识，再次存入浏览器缓存中

## 本地存储

主要分为：`Cookie` `WebStorage` `IndexedDB`，`WebStorage` 又分为 `sessionStorage` 和 `localtorage`

### Cookie 用于存储会话信息

构成：
1. name：名称，必须通过URL编码
2. value：值，字符串值，被URL编码
3. Domain：域，指明对哪个域有效
4. path：路径，指定域中的哪个路径，应该向服务器发送cookie
5. Expires/Max-Age：有效期
6. HttpOnly：如果为true，就不能通过js脚本获取cookie的值。可防止XSS攻击
7. Secure：安全标志，指定后，只有在SSL连接是才能发送到服务器

特点：
1. 数量有限，超出后回清除以前设置的Cookie
2. 大小只有 **4kb**
3. 每次HTTP请求都会默认带上，影响获取资源效率
4. 获取、设置、删除等方法需要自己封装

### localStorage

1. 永久有效，除非手动删除
2. 大小为 5M
3. 仅在客户端使用，不和服务端进行通信
4. 接口封装较好

### sessionStorage

1. 会话级别的存储
2. 大小为 5M
3. 仅在客户端使用，不和服务端进行通信
4. 接口封装较好

### localStorage 和 sessionStorage

- `localStorage` 的数据可以长期保留，`sessionStorage` 的数据在关闭页面后即被清空。
- 大小都是 5M
- 都仅在客户端使用，不和服务端进行通信
- 使用方式和API一致，`getItem` `setItem` `removeItem` `clear`

### indexedDB

- 键值对存储
- 异步
- 支持事务
- 同源策略
- 储存空间大
- 支持二进制数据

### 总结

- Cookie主要用于“维持状态”，而非本地存储数据，如 用户设置主题等
- Web Storage是专门为浏览器提供的数据存储机制，不与服务端发生通信
- IndexedDB 用于客户端存储大量结构化数据

## CDN

CDN 全称是 `Content Delivery Network`，即内容分发网络，他应用了HTTP协议里的 **缓存** 和 **代理技术**，代替源站响应客户端的请求。

CDN 依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，让用户 **就近** 获取所需内容，降低网络堵塞，提高用户访问的响应速度和命中率。关键技术主要有 **内容储存** 和 **分发技术**

比如买苹果产品，之前只能通过官网发货过海关等，现在可以直接就近在线下服务点取

## DNS

负责将域名翻译成ip地址

IP 地址转换为便于人类记忆的协议就是 DNS 协议

如 百度的IP地址，DNS 为 `www.baidu.com`

## OSI 模型

1. 应用层
2. 表示层
3. 会话层
4. 运输层
5. 网络层
6. 数据链路层
7. 物理层

## 状态码

以 **2xx** 开头的都表示请求 **成功响应**

| 状态码 | 含义                         |
| ------ | ---------------------------- |
| 200    | 成功响应                     |
| 204    | 请求处理成功，但没有资源返回 |

以 **3xx** 开头的表示 **需要进行附加操作** 以完成请求

| 状态码 | 含义                                                           |
| ------ | -------------------------------------------------------------- |
| 301    | 永久重定向，表示资源已经重新分配URI，以后应该使用新的URI       |
| 302    | 临时性重定向，表示本次资源应该使用新的URI访问                  |
| 303    | 请求对应资源存在另一个URI，应使用GET方法定向获取请求的资源     |
| 304    | 客户端发送附带条件请求，服务器端允许请求访问资源。但未满足条件 |

以 **4xx** 开头 **客户端发送错误**

| 状态码 | 含义                                         |
| ------ | -------------------------------------------- |
| 400    | 请求报文中存在语法错误                       |
| 401    | 未授权，请求需要有通过HTTP认证的**认证信息** |
| 403    | 被服务器拒绝                                 |
| 404    | 访问资源不存在                               |

以 **5xx** 开头表示 **服务器本身发生错误**

| 状态码 | 含义                              |
| ------ | --------------------------------- |
| 500    | 服务器端执行请求时发生了错误      |
| 503    | 服务器 **超负载** 或 **停机维护** |
| 504    | 网关超时                          |

## 跨域

跨域指 浏览器不能执行其他网站的脚本。由浏览器的同源策略造成，是浏览器对js实施的安全策略。**端口域名协议** 任一不同，都属于跨域

1. jsonp
2. 跨域资源共享 CORS
3. nginx 代理跨域
4. nodejs 中间件代理跨域
5. WebSocket 协议跨域
6. postMessage 跨域

## post 预检请求 OPTION

预检请求就是复杂请求（可能对服务器产生副作用的HTTP请求方法），比如 `put` `delete`

会自发的发起预请求，第一次请求的参数是 options，检测实际请求是否被浏览器接受

如：post 请求的 `content-type: application/json` 就会发生预检请求

## 重绘 回流

**回流必定重绘，重绘未必回流**

### 回流 Reflow

元素的尺寸、结构、某些属性发生改变时，浏览器重新渲染部分或全部文档的过程

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量，图片大小等）
- 元素字体大小变化
- 添加或删除可见的DOM元素
- 激活CSS伪类（如 `:hover`）
- 查询某些属性或调用某些方法

### 重绘 Repaint

元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘

### 避免

css
- 避免使用 table 布局
- 尽可能在DOM树末端改变class
- 避免设置多层内联样式
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
- 避免使用CSS表达式（例如：`calc()`）

js
- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
- 避免频繁操作DOM，创建一个`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流

## 事件机制

捕获 => 目标 => 冒泡

## 事件代理

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

- 节省内存
- 不需要给子节点注销事件

## 20. 事件循环机制（微任务和宏任务） Event Loop

详情链接参考：[面试必问之 JS 事件循环（Event Loop)](https://mp.weixin.qq.com/s/wugntKhMZpgr6RtB1AwAmQ)

事件循环是通过任务队列的机制来进行协调的。

- js 分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件
- 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行

### 宏任务

(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

`(macro)task => 渲染 => (macro)task => ...`

包含：
1. script（整体代码）
2. setTimeout
3. setInterval
4. I/O
5. UI交互事件
6. postMessage
7. MessageChannel
8. setImmediate（Node 环境）

### 微任务

microtask，可以理解是在当前task执行结束后立即执行的任务。也就是说，在当前task 任务后，下一个task之前，也在渲染之前

所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个宏任务执行完后，就会将在它执行期间产生的所有微任务都执行完毕（在渲染前）

包含：
1. Promise.then
2. Object.observe
3. MutationObserver
4. process.nextTick（Node 环境）

### 运行机制

在事件循环中，每进行一次循环操作称为 tick，每一次 tick的任务处理模型都是比较复杂的，但关键步骤如下：

1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

![EventLoop](/eventloop.png)
