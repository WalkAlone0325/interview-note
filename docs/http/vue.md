## Vue 实现原理

## 使用 Object.defineProperty() 来进行数据劫持有什么缺点

- 无法对新增和删除等属性以及通过下标的方式修改数组数据触发更新
- 因为 `Object.defineProperty()` 需要先知道对象的 `key` 值，才能对属性进行拦截

## Vue3 为什么使用 proxy 代替 Object.defineProperty() 实现响应式

- `defineProperty` 不能监听数组的变化
- 只能劫持对象的属性，给对象添加的属性无法劫持
- 因为 `defineProperty` 必须先知道对象的 `key` 值

proxy

- 可以直接监听数组的变化
- 可以直接监听整个对象，而不是对象的属性
- proxy 被重点关注的性能优化
- proxy 是 ES6 的语法，而且没有 polyfill，存在兼容性问题
- proxy 存在13种拦截方法，这是 `defineProperty` 不具备的，所以 vue2 在实现响应式时需要其他的方法辅助（如重写数组方法，增加额外的 `$set` `$delete` 方法）

## v-if 和 v-show

共同点： **都能控制元素是否显示**

区别：
- **控制手段** ： `v-show` 是通过 `display: none` 控制。DOM元素依旧存在；`v-if` 显示隐藏是将DOM元素整个添加或删除
- **编译过程** ： `v-if` 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；`v-show` 只是简单的基于css切换
- **编译条件** ： `v-if` 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
- **性能消耗** ： `v-if` 有更高的切换消耗；`v-show` 有更高的初始渲染消耗；

- `v-if` 相比 `v-show` 开销更大的（直接操作dom节点增加与删除）
- 如果需要非常频繁地切换，则使用 `v-show` 较好
- 如果在运行时条件很少改变，则使用 `v-if` 较好

## 为什么部署到服务器会有 404 错误的原因

### 为什么在 History 模式下会有问题？

Vue 是属于单页面应用，打包只会产出一个 `index.html`，地址输入 `www.xx.com` 之后会打开 `index.html`，然后跳转路由到 `www.xx.com/login`，刷新页面从服务器请求这个地址，`nginx location` 是没有配置的，所以会出现找不到资源的情况，也就是 404

### 为什么在 Hash 模式下没有问题？

Hash 是通过 `#` 表示的，他不会被包含在 HTTP 请求中，对服务端没有影响，因此改变 hash 不会重新加载页面。只有 根地址 才被包含在请求中

### 解决

需要配置将任意页面都重定向到 `index.html`，把路由交由前端处理
对 `nginx` 配置文件 `.conf` 修改，添加 `try_files $uri $uri/ /index.html;`

## 权限

- 接口权限（采用 `jwt` 的形式来验证，没有权限返回 `401`，跳转到登录页重新登录。登录完拿到token，通过 axios 请求拦截器进行拦截，每次请求的时候都在头部携带）
- 按钮权限
  - 使用 `v-if` 判断
  - 使用 自定义指令 判断
- 菜单权限
  - 菜单与路由分离，菜单由后端返回
  - 菜单和路由都由后端返回
- 路由权限
  - **静态添加** ：初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验
  - **动态添加** ： 获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用`addRoutes` 添加路由  

## nextTick

- Vue2 使用了 降级处理：`Promise.then`、`MutationObserver`、`setImmediate`、`setTimeout`
- Vue3 直接使用 `Promise.then`

使用浏览器的 Event Loop 机制

## Vue 异步更新

## Vue 的data为什么是一个函数

目的是为了防止 **多个组件实例** 对象之间公用一个 `data`，产生数据污染。采用函数的形式， `initData` 时会将其作为 **工厂函数** 都会返回 全新 `data` 对象



