## Vue 实现原理

## 使用 Object.defineProperty() 来进行数据劫持有什么缺点

- 无法对新增和删除等属性以及通过下标的方式修改数组数据触发更新
- 因为 `Object.defineProperty()` 需要先知道对象的 `key` 值，才能对属性进行拦截

## Vue3 为什么使用 proxy 代替 Object.defineProperty() 实现响应式

- `defineProperty` 不能监听数组的变化
- 只能劫持对象的属性，给对象添加的属性无法劫持
- 因为 `defineProperty` 必须先知道对象的 `key` 值

proxy

- 可以直接监听数组的变化
- 可以直接监听整个对象，而不是对象的属性
- proxy 被重点关注的性能优化
- proxy 是 ES6 的语法，而且没有 polyfill，存在兼容性问题
- proxy 存在13种拦截方法，这是 `defineProperty` 不具备的，所以 vue2 在实现响应式时需要其他的方法辅助（如重写数组方法，增加额外的 `$set` `$delete` 方法）

## v-if 和 v-show

共同点： **都能控制元素是否显示**

区别：
- **控制手段** ： `v-show` 是通过 `display: none` 控制。DOM元素依旧存在；`v-if` 显示隐藏是将DOM元素整个添加或删除
- **编译过程** ： `v-if` 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；`v-show` 只是简单的基于css切换
- **编译条件** ： `v-if` 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
- **性能消耗** ： `v-if` 有更高的切换消耗；`v-show` 有更高的初始渲染消耗；

- `v-if` 相比 `v-show` 开销更大的（直接操作dom节点增加与删除）
- 如果需要非常频繁地切换，则使用 `v-show` 较好
- 如果在运行时条件很少改变，则使用 `v-if` 较好

## 为什么部署到服务器会有 404 错误的原因

### 为什么在 History 模式下会有问题？

Vue 是属于单页面应用，打包只会产出一个 `index.html`，地址输入 `www.xx.com` 之后会打开 `index.html`，然后跳转路由到 `www.xx.com/login`，刷新页面从服务器请求这个地址，`nginx location` 是没有配置的，所以会出现找不到资源的情况，也就是 404

### 为什么在 Hash 模式下没有问题？

Hash 是通过 `#` 表示的，他不会被包含在 HTTP 请求中，对服务端没有影响，因此改变 hash 不会重新加载页面。只有 根地址 才被包含在请求中

### 解决

需要配置将任意页面都重定向到 `index.html`，把路由交由前端处理
对 `nginx` 配置文件 `.conf` 修改，添加 `try_files $uri $uri/ /index.html;`

## 权限

- 接口权限（采用 `jwt` 的形式来验证，没有权限返回 `401`，跳转到登录页重新登录。登录完拿到token，通过 axios 请求拦截器进行拦截，每次请求的时候都在头部携带）
- 按钮权限
  - 使用 `v-if` 判断
  - 使用 自定义指令 判断
- 菜单权限
  - 菜单与路由分离，菜单由后端返回
  - 菜单和路由都由后端返回
- 路由权限
  - **静态添加** ：初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验
  - **动态添加** ： 获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用`addRoutes` 添加路由  

## nextTick

- Vue2 使用了 降级处理：`Promise.then`、`MutationObserver`、`setImmediate`、`setTimeout`
- Vue3 直接使用 `Promise.then`

使用浏览器的 Event Loop 机制

## Vue 异步更新

## Vue 的data为什么是一个函数

目的是为了防止 **多个组件实例** 对象之间公用一个 `data`，产生数据污染。采用函数的形式， `initData` 时会将其作为 **工厂函数** 都会返回 全新 `data` 对象

## Vue 组件通信

- 父子组件（props / $emit / $parent / ref / $attrs）
- 兄弟组件（$parent / $root / eventbus / vuex / pinia）
- 跨层级组件（vuex / pinia / provide + inject）

## v-if 和 v-for 优先级

- 在vue2中，v-for 的优先级更高 （每一次循环都要进行判断，源码中先处理的 v-for）
- 在vue3中，v-if 的优先级更高（会直接报错，先处理 v-if）
- 不要把这两个指令放到一个元素上

## 简述Vue生命周期

创建 =》 更新 =》 销毁

每个Vue组件实例被创建后都会经过一系列初始化步骤，比如，需要数据观测，模版编译，挂载实例到 DOM上，以及数据变化时更新DOM。这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段添加自己的代码

Vue生命周期总共可以分为 8 个阶段：创建前后，载入前后，更新前后，销毁前后。以及一些特殊场景的生命周期。Vue3中新增了 三 个用于调试和服务端渲染场景


**composition API 中最早触发的是 `setup`**

| vue2          | vue3            | 描述                             |
| ------------- | --------------- | -------------------------------- |
| beforeCreate  | beforeCreate    | 组件实例被创建之前               |
| created       | created         | 组件实例已经完成创建             |
| beforeMount   | beforeMount     | DOM 挂载之前                     |
| mounted       | mounted         | DOM 挂载完成之后                 |
| beforeUpdate  | beforeUpdate    | 组件 更新之前                    |
| updated       | updated         | 组件 更新完成之后                |
| beforeDestory | beforeUnmount   | 组件 卸载之前                    |
| destoryed     | unmounted       | 组件 卸载完成之后                |
|               |                 |                                  |
| activited     | activited       | KeepAlive 组件 被激活时          |
| deactivited   | deactivited     | KeepAlive 组件 被停用时          |
| errorCaptured | errorCaptured   | 捕获来自子孙组件的错误时         |
|               | renderTracked   | 调试钩子，响应式依赖被手机时调用 |
|               | renderTriggered | 调试钩子，响应式依赖被触发时调用 |
|               | serverPrefetch  | 组件实例在服务器上被渲染前       |

- `beforeCreate` ： 通常用于插件开发中执行一些初始化任务
- `created` ：组件初始化完毕，可以访问各种数据，获取接口数据等
- `mounted` ：dom 已创建，可以获取访问数据和DOM元素；访问子组件等
- `beforeUpdate` ：此时 view 层还未更新，可用于获取更新前的状态
- `updated` ：完成 view 的更新，更新后，所有状态已是最新
- `beforeUnmount` ：实例销毁前调用，可用于一些定时器或订阅的取消
- `unmounted` ： 销毁一个实例，可以清理与其它实例的连接，解绑他的全部指令及事件监听器

### setup 中为什么没有 beforeCreate 和 created？

setup 函数中组件实例已经创建了，已经完成了 beforeCreate 和 created 所做的事情

## 双向绑定的原理和使用

1. 给出双向绑定的定义
2. 双绑带来的好处
3. 在哪使用双绑
4. 使用方式、使用细节、vue3 变化
5. 原理实现描述

回答：
1. 双向绑定是一个指令 `v-model`，可以绑定一个响应式数据到视图，同时视图中变化能改变该值
2. 是一个语法糖，默认情况下相当于 `:value` 和 `@input`。可以减少大量是 绑定和事件处理代码
3. 通常在表单项上使用 `v-model`，还可以在自定义组件上使用，表示某个值的输入和输出控制
4. 还可以使用 `.lazy` `.trim` `.number` 进行修饰符的限制。Vue3中可以绑定多个`v-model`，去除了Vue2中的 `.sync`
5. 编译时，input 默认是 `@input`，使用 `.lazy` 是 `@change` 事件，其它如 `checkbox` `radio` 是 `:checked` 和 `@change`事件， `select` 是 `:value` 和 `@change` 事件

## 扩展一个组件

- 逻辑扩展： `mixins`， `extends`， `composition api`
- 内容扩展： `slots`

## 子组件是否可以直接修改父组件的数据

单向数据流，所有的 props 都遵循着**单向绑定**原则，避免了子组件因意外修改父组件的数据（浏览器控制台会出现警告），是数据流变得混乱而难以理解。大多数情况下应该使用 `自定义事件` 来通知父组件来做出改变

## 数据响应式理解

思路
- 啥是响应式
- 为什么vue需要响应式
- 带来什么好处
- 怎么实现的？有哪些优缺点
- Vue3的响应式新变化

1. 响应式就是能够是数据变化可以被检测并对这种变化做出响应的机制
2. MVVM 框架中要解决的问题是连接数据层和视图层，通过 **数据驱动**应用，数据变化，视图更新。即一旦数据发生变化就立即做出更新处理
3. vue以数据响应加上虚拟DOM和patch算法，开发人员只要操作数据，关心业务，完全不需要接触频繁的DOM操作，从而大大提升开发效率，降低开发难度
4. Vue2中根据不同数据类型来做不同处理，如果是对象采用`Object.defineProperty`方式定义数据拦截，当数据被访问或发生变化时做出响应；如果是数组则通过覆盖数据对象原型的7个变更方法，是这些方法可以额外的做更新通知，从而做出响应。缺点：初始化时递归遍历会造成性能损失；新增或删除属性时需要用户使用 `$set` `$delete`；对ES6中新产生的 `Map` `Set` 这些数据结构不支持
5. Vue3使用ES6的proxy代理要响应化的数据。编程体验一致，不需要额外的api；初始化性能和内存得到提升；并且单独抽离了 `reactivity` 包，使得我们可以更灵活的使用它

## 对虚拟DOM的理解

思路
- vdom 是什么
- 好处
- vdom如何生成，又如何成为 DOM
- 在后续Diff中发作用

回答
1. 虚拟DOM 是一个 虚拟的DOM对象，本质是一个 `js对象`，用来描述一个视图结构
2. 好处：
   1. **将真实元素节点抽象成 VNODE，有效减少直接操作DOM次数，从而提高程序性能**
      1. 使用js来操作DOM，变得简单，比如 Diff（比对） 和 clone（克隆）
      2. 频繁操作DOM会引起页面的回流和重绘，但使用VNode进行中间处理，可以有效减少直接操作dom的次数，减少回流和重绘
   2. **方便实现跨平台**
3. 如何生成？`template` => compiler（AST => generate => code） => `render` => `VNode` => `真实DOM`
4. 挂载过程结束后，Vue程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新compiler，此时会生成新的 vdom，和上一次渲染结果进行 diff 就能得到变化的地方，从而转换为最小量的 dom操作，高效更新视图

## diff 算法

- diff是干什么的
- 必要性
- 何时执行
- 具体执行方式
- vue3 中的优化

回答：
1. diff 算法称为 patch 算法，虚拟DOM要想转化为真实DOM就需要通过patch
2. patch 过程是一个递归过程。遵循 深度优先，同层比较的策略
   1. 先判断两个节点是否为相同同类节点，不同则删除重新创建
   2. 如果双方都是文本则更新文本内容
   3. 如果双方都是元素节点则递归更新子元素，同时更新元素属性
   4. 更新子节点时分为：
      1. 新子是文本，老子是数组，则清空设置文本
      2. 新子是文本，老子是文本，则更新内容
      3. 新子是数组，老子是文本，则清空文本，创建新子的数组中的子元素
      4. 新子是数组，老子是数组，比较两个数组，找出最小不同点

3. vue3优化：block树，静态提升，优化patchFlags等
